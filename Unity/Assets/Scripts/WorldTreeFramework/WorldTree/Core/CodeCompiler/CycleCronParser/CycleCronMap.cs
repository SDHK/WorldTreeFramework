namespace WorldTree
{
	/// <summary>
	/// 周期Cron模式枚举
	/// 用于指定表达式的解析模式和字段含义
	/// </summary>
	public enum CycleCronMode : byte
	{
		/// <summary>
		/// 模式1：日期+月份+年轮
		/// 格式：秒 分 时 日期 月份 年轮 轮次范围 (7个字段)
		/// 适用：按日历日期调度（每月X号）
		/// </summary>
		DateMonthYear = 1,

		/// <summary>
		/// 模式2：星期+月份+年轮
		/// 格式：秒 分 时 星期 月份 年轮 轮次范围 (7个字段)
		/// 适用：按星期调度（每周X，每月第N个周X）
		/// </summary>
		WeekMonthYear = 2,

		/// <summary>
		/// 模式3：星期轮
		/// 格式：秒 分 时 星期 星期轮 轮次范围 (6个字段)
		/// 适用：按周循环（每N周的周X）
		/// </summary>
		Week = 3,

		/// <summary>
		/// 模式4：天数轮（最灵活）
		/// 格式：秒 分 时 天数轮 轮次范围 (5个字段)
		/// 适用：任意天数周期（每N天执行）
		/// </summary>
		Day = 4
	}

	/// <summary>
	/// 周期Cron表达式位图 (36字节，288位)
	/// 高性能调度规则存储结构，通过位图实现极致的内存占用和匹配速度
	/// 
	/// 设计理念：
	/// - 模式与表达式分离：Mode作为独立字段，表达式更接近传统Cron
	/// - 职责分离：只存储调度规则，时区由外部DateTime处理
	/// - 位图编码：所有时间字段用位图存储，实现O(1)匹配性能
	/// </summary>
	public class CycleCronMap
	{
		/// <summary>
		/// 模式标识 (1-4，预留5-255扩展)
		/// 决定了表达式的解析方式和字段含义
		/// 注意：Mode不在表达式字符串中，而是作为独立参数传入
		/// </summary>
		public CycleCronMode Mode;

		/// <summary>
		/// 秒位图 (0-59)
		/// 64位可表示60个值，每个bit对应一个秒数
		/// </summary>
		public ulong Seconds;

		/// <summary>
		/// 分钟位图 (0-59)
		/// 64位可表示60个值，每个bit对应一个分钟数
		/// </summary>
		public ulong Minutes;

		/// <summary>
		/// 小时位图 (0-23)
		/// 32位中使用低24位，每个bit对应一个小时
		/// </summary>
		public uint Hours;

		/// <summary>
		/// 天/星期位图 (根据模式动态解释)
		/// 模式1: 位1-31表示日期1-31
		/// 模式2/3: 位1-7表示星期1-7 (1=周一, 2=周二...7=周日)
		/// 模式4: 不使用
		/// </summary>
		public uint Days;

		/// <summary>
		/// 月位图 (1-12)
		/// 16位中使用低13位，bit1-12对应月份1-12
		/// </summary>
		public ushort Months;

		/// <summary>
		/// 轮次位图 + 轮次范围 (64位)
		/// 位63-56: 轮次范围 (8位, 1-52, 0表示默认52)
		/// 位55-52: 预留扩展 (4位)
		/// 位51-0:  轮次位图 (52位, 每位对应一个轮次)
		/// </summary> 
		public ulong Cycles;

		/// <summary>
		/// 特殊符号编码 (8位, 根据模式动态解释)
		/// 
		/// === 模式1: 日期字段 ===
		/// bit 7-5: 符号类型 (3位, 8种状态)
		///   000 (0) = 普通日期
		///   001 (1) = L (Last, 月末倒数)
		///   010 (2) = W (Weekday, 工作日调整)
		///   011 (3) = LW (月末工作日)
		///   100-111 = 预留扩展
		/// bit 4-0: 日期值 (5位, 0-31)
		/// 示例: 0x0F=15号, 0x2F=15W, 0x20=L, 0x60=LW
		/// 
		/// === 模式2/3: 星期字段 ===
		/// bit 7:   L标志 (1=最后一个)
		/// bit 6:   #标志 (1=第N个)
		/// bit 5-3: 星期几 (1-7, 1=周一...7=周日)
		/// bit 2-0: 第N个 (1-5, 0=不使用)
		/// 示例: 0x68=5#3(第3个周五), 0xE8=5L(最后一个周五)
		/// 
		/// === 模式4: 不使用 ===
		/// 0x00
		/// </summary>
		public byte DayOffset;

		// 总计: 8+64+64+32+32+16+64+8 = 288位 = 36字节
	}

	/*
		==============================================================================
		CycleCron 表达式设计文档
		==============================================================================
		
		注：防止注释报错，文档中的 / 符号写成 \
		
		一、设计理念
		------------
		CycleCron 是专为游戏服务器设计的高性能周期调度系统，核心特点：
		1. 轮次抽象：突破传统Cron的日历限制，支持任意周期长度
		2. 极致性能：36字节存储，位运算匹配，适合百万级任务调度
		3. 职责分离：只负责调度规则，时区由外部DateTime处理
		4. 开服锚点：以开服时间为基准，完美契合游戏场景
		
		
		二、4种模式说明（空格分隔字段，字段内用逗号分隔值）
		------------------------------------------------------------
		
		重要：模式号(Mode)不在表达式字符串中，而是作为独立参数传入解析器
		
		【模式1：日期+月份+年轮 (CycleCronMode.DateMonthYear)】
		格式：秒 分 时 日期 月份 年轮 轮次范围 (7个字段)
		说明：
		  - 年轮：指定年份的间隔（如 2\1 = 从第2年开始每1年）
		  - 轮次范围：多少年为一个完整周期（1-52）
		API：
		  Parse("0 0 9 1,15 * *\1 12", CycleCronMode.DateMonthYear)
		  ParseDateMonthYear("0 0 9 1,15 * *\1 12")
		示例：
		  "0 0 9 1,15 * *\1 12" = 每月1号和15号9点，12年循环
		  "0 0 12 L * *\1 1" = 每月最后一天12点
		  "0 0 12 15W * *\1 1" = 每月15号最近的工作日12点
		
		【模式2：星期+月份+年轮 (CycleCronMode.WeekMonthYear)】
		格式：秒 分 时 星期 月份 年轮 轮次范围 (7个字段)
		说明：
		  - 星期：1-7 (1=周一, 2=周二...7=周日)
		  - 年轮：指定年份的间隔
		API：
		  Parse("0 0 0 1-5 * *\1 1", CycleCronMode.WeekMonthYear)
		  ParseWeekMonthYear("0 0 0 1-5 * *\1 1")
		示例：
		  "0 0 0 1-5 * *\1 1" = 周一到周五0点（工作日）
		  "0 0 0 5#3 1,6 *\1 1" = 1月和6月的第3个周五
		  "0 0 0 5L * *\1 1" = 每月最后一个周五
		
		【模式3：星期轮 (CycleCronMode.Week)】
		格式：秒 分 时 星期 星期轮 轮次范围 (6个字段)
		说明：
		  - 星期轮：指定周的间隔（如 *\2 = 每隔一周）
		  - 轮次范围：多少周为一个完整周期（1-52）
		API：
		  Parse("0 0 0 1,5 *\2 2", CycleCronMode.Week)
		  ParseWeek("0 0 0 1,5 *\2 2")
		示例：
		  "0 0 0 1,5 *\2 2" = 每隔一周的周一、周五0点
		  "0 0 12 * *\1 4" = 每周12点，4周循环
		
		【模式4：天数轮 (CycleCronMode.Day)】（最灵活）
		格式：秒 分 时 天数轮 轮次范围 (5个字段)
		说明：
		  - 天数轮：指定天数的间隔（抽象轮次）
		  - 轮次范围：多少天为一个完整周期（1-52）
		API：
		  Parse("0 0 12 *\7 28", CycleCronMode.Day)
		  ParseDay("0 0 12 *\7 28")
		示例：
		  "0 0 12 *\7 28" = 每7天12点，28天循环
		  "0 0 0 *\1 28" = 每天0点，28天循环（生理周期）
		  "0 0 0 *\3 15" = 每3天0点，15天循环
		
		注：模式1的"年轮"对应日历年份，模式3/4的"轮次"是抽象周期单位
		
		设计优势：
		  ✓ 表达式更简洁，不含模式号
		  ✓ 语义更清晰，模式独立指定
		  ✓ 便于验证，根据模式检查字段数量
		  ✓ API更友好，提供类型安全的枚举和专用方法
		
		
		三、API使用示例
		----------------
		
		// 方式1：使用枚举（推荐，类型安全）
		var cron1 = CycleCronParser.Parse("0 0 9 1,15 * *\1 12", CycleCronMode.DateMonthYear);
		
		// 方式2：使用专用方法（最清晰）
		var cron2 = CycleCronParser.ParseDateMonthYear("0 0 9 1,15 * *\1 12");
		var cron3 = CycleCronParser.ParseWeekMonthYear("0 0 0 1-5 * *\1 1");
		var cron4 = CycleCronParser.ParseWeek("0 0 0 1,5 *\2 2");
		var cron5 = CycleCronParser.ParseDay("0 0 12 *\7 28");
		
		// 配置文件示例
		{
		  "mode": "DateMonthYear",  // 或使用数字 1
		  "expression": "0 0 9 1,15 * *\1 12",
		  "description": "每月1号和15号早上9点"
		}
		
		
		四、字段取值范围
		----------------
		- 模式号: 1-4 (当前), 5-255 (预留扩展)
		- 秒: 0-59
		- 分: 0-59
		- 时: 0-23
		- 日期: 1-31
		- 星期: 1-7 (1=周一, 2=周二...7=周日，注意不兼容0-6)
		- 月份: 1-12
		- 轮次: 1-52（位图最大支持）
		- 轮次范围: 1-52（省略或*表示全范围52）
		
		
		五、支持的特殊符号
		------------------
		基础符号：
		  *   : 所有值
		  \   : 步长（如 *\2 = 每隔2个，2\3 = 从2开始每隔3个）
		  -   : 范围（如 1-5 = 1,2,3,4,5）
		  ,   : 列举（如 1,3,5 = 第1、3、5个）
		
		高级符号（模式1-日期字段）：
		  L   : Last，月末最后一天（如 L = 月末，L-1 = 月末倒数第2天）
		  W   : Weekday，最近工作日（如 15W = 15号最近的工作日）
		  LW  : 月末最后一个工作日
		
		高级符号（模式2/3-星期字段）：
		  #   : 第N个星期X（如 5#3 = 第3个周五）
		  L   : 最后一个星期X（如 5L = 最后一个周五）
		
		注：# 和 W 是互斥的（#用于星期，W用于日期）
		
		
		六、存储设计（36字节，288位）
		----------------------------
		
		【Mode字段 - 8位】
		- 全部8位用于模式类型（1-255）
		
		【Cycles字段 - 64位】
		- 位 63-56: 轮次范围（8位，1-52，0=默认52）
		- 位 55-52: 预留扩展（4位）
		- 位 51-0:  轮次位图（52位，每位代表对应轮次是否触发）
		
		【DayOffset字段 - 8位】
		模式1编码：
		  - 位 7-5: 符号类型（000=普通, 001=L, 010=W, 011=LW, 100-111=预留）
		  - 位 4-0: 日期值（0-31）
		模式2/3编码：
		  - 位 7: L标志
		  - 位 6: #标志
		  - 位 5-3: 星期几（1-7，1=周一...7=周日）
		  - 位 2-0: 第N个（1-5）
		
		
		七、轮次计算规则
		----------------
		- 轮次起点：从开服时间（或指定基准时间）作为第1轮的起始点
		- 轮次递增：根据模式自动计算当前处于第几轮
		  * 模式1: 按年累加
		  * 模式2: 按年累加
		  * 模式3: 按周累加
		  * 模式4: 按天累加
		- 轮次循环：达到轮次范围后自动重置为第1轮
		- 轮次匹配：通过位图快速判断当前轮次是否触发（O(1)复杂度）
		
		
		八、时区处理说明
		----------------
		CycleCron 是纯调度规则，不包含时区信息。
		时区转换由外部DateTime层处理，调用者需要传入正确时区的时间：
		
		示例1：全局UTC活动
		  DateTime utcTime = DateTime.UtcNow;
		  if (globalCron.IsMatch(utcTime)) { StartEvent(); }
		
		示例2：服务器本地活动
		  DateTime serverTime = GetServerLocalTime();
		  if (serverCron.IsMatch(serverTime)) { StartEvent(); }
		
		示例3：玩家个人任务
		  DateTime playerTime = GetPlayerLocalTime(player);
		  if (player.dailyCron.IsMatch(playerTime)) { CompleteDaily(); }
		
		优势：职责分离，规则可复用，性能更高，灵活性更强
		
		
		九、与传统Cron对比
		------------------
		优势：
		  ✓ 支持任意周期长度（每7天、每2周等，传统Cron做不到）
		  ✓ 极致性能（36字节 vs 500字节，位运算 vs 字符串解析）
		  ✓ 轮次抽象（完美契合游戏服务器场景）
		  ✓ 开服锚点（支持相对时间调度）
		
		局限：
		  ✗ 不支持复杂日历逻辑（浮动节日如复活节）
		  ✗ 不包含调度引擎（需要外部实现）
		  ✗ 不包含持久化方案（需要外部实现）
		
		定位：游戏服务器专用的高性能周期调度器，而非通用企业级任务调度系统
		
		==============================================================================
	


	 
	 
	 
	 */

}
