namespace WorldTree
{
	/// <summary>
	/// 周期Cron模式枚举
	/// 用于指定表达式的解析模式和字段含义
	/// </summary>
	public enum CycleCronMode : byte
	{
		/// <summary>
		/// 模式1：日期+月份+年轮
		/// 格式：秒 分 时 日期 月份 年轮 轮次范围 (7个字段)
		/// 适用：按日历日期调度（每月X号）
		/// </summary>
		DateMonthYear = 1,

		/// <summary>
		/// 模式2：星期+月份+年轮
		/// 格式：秒 分 时 星期 月份 年轮 轮次范围 (7个字段)
		/// 适用：按星期调度（每周X，每月第N个周X）
		/// </summary>
		WeekMonthYear = 2,

		/// <summary>
		/// 模式3：星期轮
		/// 格式：秒 分 时 星期 星期轮 轮次范围 (6个字段)
		/// 适用：按周循环（每N周的周X）
		/// </summary>
		Week = 3,

		/// <summary>
		/// 模式4：天数轮（最灵活）
		/// 格式：秒 分 时 天数轮 轮次范围 (5个字段)
		/// 适用：任意天数周期（每N天执行）
		/// </summary>
		Day = 4
	}

	/*
		==============================================================================
		CycleCron 表达式设计文档
		==============================================================================
		
		注：防止注释报错，文档中的 / 符号写成 \
		
		一、设计理念
		------------
		CycleCron 核心特点：
		1. 轮次抽象：突破传统Cron的日历限制，支持任意周期长度
		2. 极致性能：36字节存储，位运算匹配，适合百万级任务调度
		3. 职责分离：只负责调度规则，时区由外部DateTime处理
		4. 开服锚点：以开服时间为基准，完美契合游戏场景
		
		
		二、4种模式说明（空格分隔字段，字段内用逗号分隔值）
		------------------------------------------------------------
		
		重要：模式号(Mode)不在表达式字符串中，而是作为独立参数传入解析器
		
		【模式1：日期+月份+年轮 (CycleCronMode.DateMonthYear)】
		格式：秒 分 时 日期 月份 年轮 轮次范围 (7个字段)
		说明：
		  - 年轮：指定年份的间隔（如 2\1 = 从第2年开始每1年）
		  - 轮次范围：多少年为一个完整周期（1-56）
		API：
		  Parse("0 0 9 1,15 * *\1 12", CycleCronMode.DateMonthYear)
		  ParseDateMonthYear("0 0 9 1,15 * *\1 12")
		示例：
		  "0 0 9 1,15 * *\1 12" = 每月1号和15号9点，12年循环
		  "0 0 12 L * *\1 1" = 每月最后一天12点
		  "0 0 12 15W * *\1 1" = 每月15号最近的工作日12点
		
		【模式2：星期+月份+年轮 (CycleCronMode.WeekMonthYear)】
		格式：秒 分 时 星期 月份 年轮 轮次范围 (7个字段)
		说明：
		  - 星期：1-7 (1=周一, 2=周二...7=周日)
		  - 年轮：指定年份的间隔
		API：
		  Parse("0 0 0 1-5 * *\1 1", CycleCronMode.WeekMonthYear)
		  ParseWeekMonthYear("0 0 0 1-5 * *\1 1")
		示例：
		  "0 0 0 1-5 * *\1 1" = 周一到周五0点（工作日）
		  "0 0 0 5#3 1,6 *\1 1" = 1月和6月的第3个周五
		  "0 0 0 5L * *\1 1" = 每月最后一个周五
		
		【模式3：星期轮 (CycleCronMode.Week)】
		格式：秒 分 时 星期 星期轮 轮次范围 (6个字段)
		说明：
		  - 星期轮：指定周的间隔（如 *\2 = 每隔一周）
		  - 轮次范围：多少周为一个完整周期（1-56）
		API：
		  Parse("0 0 0 1,5 *\2 2", CycleCronMode.Week)
		  ParseWeek("0 0 0 1,5 *\2 2")
		示例：
		  "0 0 0 1,5 *\2 2" = 每隔一周的周一、周五0点
		  "0 0 12 * *\1 4" = 每周12点，4周循环
		
		【模式4：天数轮 (CycleCronMode.Day)】（最灵活）
		格式：秒 分 时 天数轮 轮次范围 (5个字段)
		说明：
		  - 天数轮：指定天数的间隔（抽象轮次）
		  - 轮次范围：多少天为一个完整周期（1-56）
		API：
		  Parse("0 0 12 *\7 28", CycleCronMode.Day)
		  ParseDay("0 0 12 *\7 28")
		示例：
		  "0 0 12 *\7 28" = 每7天12点，28天循环
		  "0 0 0 *\1 28" = 每天0点，28天循环（生理周期）
		  "0 0 0 *\3 15" = 每3天0点，15天循环
		
		注：模式1的"年轮"对应日历年份，模式3/4的"轮次"是抽象周期单位
		
		设计优势：
		  ✓ 表达式更简洁，不含模式号
		  ✓ 语义更清晰，模式独立指定
		  ✓ 便于验证，根据模式检查字段数量
		  ✓ API更友好，提供类型安全的枚举和专用方法
		
		
		三、API使用示例
		----------------
		
		// 方式1：使用枚举（推荐，类型安全）
		var cron1 = CycleCronParser.Parse("0 0 9 1,15 * *\1 12", CycleCronMode.DateMonthYear);
		
		// 方式2：使用专用方法（最清晰）
		var cron2 = CycleCronParser.ParseDateMonthYear("0 0 9 1,15 * *\1 12");
		var cron3 = CycleCronParser.ParseWeekMonthYear("0 0 0 1-5 * *\1 1");
		var cron4 = CycleCronParser.ParseWeek("0 0 0 1,5 *\2 2");
		var cron5 = CycleCronParser.ParseDay("0 0 12 *\7 28");
		
		// 配置文件示例
		{
		  "mode": "DateMonthYear",  // 或使用数字 1
		  "expression": "0 0 9 1,15 * *\1 12",
		  "description": "每月1号和15号早上9点"
		}
		
		
		四、字段取值范围
		----------------
		- 模式号: 1-4 (当前), 5-255 (预留扩展)
		- 秒: 0-59
		- 分: 0-59
		- 时: 0-23
		- 日期: 1-31
		- 星期: 1-7 (1=周一, 2=周二...7=周日，注意不兼容0-6)
		- 月份: 1-12
		- 轮次: 1-56（位图最大支持）
		- 轮次范围: 1-56（省略或*表示全范围56）
		
		
		五、支持的特殊符号
		------------------
		基础符号：
		  *   : 所有值
		  \   : 步长（如 *\2 = 每隔2个，2\3 = 从2开始每隔3个）
		  -   : 范围（如 1-5 = 1,2,3,4,5）
		  ,   : 列举（如 1,3,5 = 第1、3、5个）
		
		高级符号（模式1-日期字段）：
		  L   : Last，月末最后一天（如 L = 月末，L-1 = 月末倒数第2天）
		  W   : Weekday，最近工作日（如 15W = 15号最近的工作日）
		  LW  : 月末最后一个工作日
		
		高级符号（模式2/3-星期字段）：
		  #   : 第N个星期X（如 5#3 = 第3个周五）
		  L   : 最后一个星期X（如 5L = 最后一个周五）
		
		注：# 和 W 是互斥的（#用于星期，W用于日期）
		
		
		六、存储设计（36字节，288位）
		----------------------------
		
	【Mode字段 - 8位】
	- 全部8位用于模式类型（1-255）
	
	【Dates字段 - 32位】
	- 模式1: 位1-31表示日历日期（1号、2号...31号）
	- 模式2/3: 位1-7表示星期几（1=周一...7=周日，复用此字段）
	- 模式4: 不使用（Day模式的天数在Cycles中）
	
	【Cycles字段 - 64位】
	- 位 63-56: 轮次范围（8位，1-56，0=默认56）
	- 位 55-0:  轮次位图（56位，每位代表对应轮次是否触发）
	- 模式1/2: 表示年轮次
	- 模式3: 表示周轮次
	- 模式4: 表示天轮次
	
	【DateOffset字段 - 8位】
	模式1编码（日期特殊符号）：
	  - 位 7-6: 符号类型（00=普通, 01=L, 10=W, 11=LW）
	  - 位 5-0: 日期值/偏移量（0-63）
	模式2/3编码（星期特殊符号）：
	  - 位 7:   #标志（1=第N个）
	  - 位 6:   L标志（1=最后一个）
	  - 位 5-3: 第N个（1-5，#时使用，L时为0）
	  - 位 2-0: 星期几（1-7，1=周一...7=周日）
		
		
		七、轮次计算规则
		----------------
		- 轮次起点：从开服时间（或指定基准时间）作为第1轮的起始点
		- 轮次递增：根据模式自动计算当前处于第几轮
		  * 模式1: 按年累加
		  * 模式2: 按年累加
		  * 模式3: 按周累加
		  * 模式4: 按天累加
		- 轮次循环：达到轮次范围后自动重置为第1轮
		- 轮次匹配：通过位图快速判断当前轮次是否触发（O(1)复杂度）
		
		
		八、时区处理说明
		----------------
		CycleCron 是纯调度规则，不包含时区信息。
		时区转换由外部DateTime层处理，调用者需要传入正确时区的时间：
		
		示例1：全局UTC活动
		  DateTime utcTime = DateTime.UtcNow;
		  if (globalCron.IsMatch(utcTime)) { StartEvent(); }
		
		示例2：服务器本地活动
		  DateTime serverTime = GetServerLocalTime();
		  if (serverCron.IsMatch(serverTime)) { StartEvent(); }
		
		示例3：玩家个人任务
		  DateTime playerTime = GetPlayerLocalTime(player);
		  if (player.dailyCron.IsMatch(playerTime)) { CompleteDaily(); }
		
		优势：职责分离，规则可复用，性能更高，灵活性更强
		
		
		九、与传统Cron对比
		------------------
		优势：
		  ✓ 支持任意周期长度（每7天、每2周等，传统Cron做不到）
		  ✓ 极致性能（36字节 vs 500字节，位运算 vs 字符串解析）
		  ✓ 轮次抽象（完美契合游戏服务器场景）
		  ✓ 开服锚点（支持相对时间调度）
		
		局限：
		  ✗ 不支持复杂日历逻辑（浮动节日如复活节）
		  ✗ 不包含调度引擎（需要外部实现）
		  ✗ 不包含持久化方案（需要外部实现）
		
		定位：游戏服务器专用的高性能周期调度器，而非通用企业级任务调度系统
		
		==============================================================================
	


	 
	 
	 
	 */

}
